# 다이나믹 프로그래밍
# 많은 메모리, 시간이 소요하는 문제는 컴퓨터도 해결하기 어렵다
# => 메모리를 좀 더 사용하더라도 시간을 줄이는 방법: 다이나믹프로그래밍(동적 계획법)
# 이미 한 계산을 반복하지 않는 방법
# 조건: 1. 큰문제를 작은 문제로 나눌수 있다.
#       2. 작은 문제의 답이 큰문제에서도 동일하다.
# 완전탐색으로 접근했을 때 시간이 오래걸리면 다이나믹 프로그래밍을 적용할 수 있는지 확인해보자

# 동적할당(dynamic allocation): 자료구조에서 프로그램 실행에 필요한 메모리를 할당하는 기법 
#                               다이나믹 프로그래밍의 다이나믹과 다른 의미

# 다이나믹프로그래밍 예시: 피보나치 수열(재귀함수 이용) 
def pibo1(n):
    if n ==1 or n == 2:
        return 1
    return pibo1(n-1)+pibo1(n-2) # 이런식의 방법은 n이 커질수록 중복된다.

# 메모이제이션 기법: 한번 구한 결과를 리스트에 넣어두고 다시 필요할 때마다 꺼내쓴다.
#                 다이나밍 프로그래밍의 한 종류, 값을 저장하므로 캐싱(caching)이라고도 한다.
# 피보나치 수열(메모이제이션,탑다운)
d = [0] * 100 # 이미 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
def pibo2(n):
    if n ==1 or n == 2:
        return 1
    if d[n] != 0: # 이미 계산한적 있다면 그대로 반환
        return d[n] 
    d[n] = pibo2(n-1)+pibo2(n-2) # 아직 계산 안했다면 점화식 따라 결과 반환
    return d[n]
# 피보나치 수열(DP테이블,보텀업)
d = [0] * 100
n = 99
d[1] = 1
d[2] = 1
for i in range(3,n+1):
    d[i] = d[i-1]+d[i-2]
print(d[n])   

# 재귀 함수를 이용하면 오버헤드 발생 할 수 있다, 스택의 크기가 한정 => 일반적으로 반복문을 사용하는게 성능 좋다
# setrecursionlimit()함수를 통해 재귀 제한을 완화할 수는 있지만 보텀업을 사용 권장
# 탑다운(큰것에서 작은것): 재귀함수 이용, 메모이제이션기법 
# 바텀업(작은것에서 큰것): 반복문 이용, DP테이블이용
