# DFS: 깊이 우선 탐색, 그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘 
# 그래프의 기본 구조: 노드, 간선, 인접하다(간선으로 연결되어있다면)
# 그래프의 2종류 : 
#     1) 인접 행렬: 2차원 배열에 각 노드가 연결된 형태를 기록 (연결안되면 무한, 자신은 0 나머지는 간선)
#                 : 모든 관계를 저장해야되서 노드가 많을 수록 메모리 낭비 
#                   두 노드가 연결되있는지 확인 빠름 graph[1][1]이런식으로 확인
INF = 987654321
graph = [
    [0,7,5],
    [7,0,INF],
    [5,INF,0]
]
#      2)인접 리스트: 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장 
#                  : 연결된 노드 정보만 저장하기 때문에 메모리 효율적 
#                    두 노드가 연결되있는지 확인 느림(연결된 데이터 다 확인해야해서)
graph2 =[[] for _ in range(3)]
graph2[0].append((1,7))
graph2[0].append((2,5))
graph2[1].append((0,7))
graph2[2].append((0,5))

#DFS 설명: 특정 경로에서 특정 상황에 깊이 들어가 노드를 방문 후 다시 돌아가 다른 경로 탐색 
#          1번노드 방문처리, 스택에 넣고 인접 노드(가장작은 수) 방문 => 그노드의 인접노드 방문 스택 넣고,방문처리 =>....
#          특정 노드에 인접노드가 없거나 인접노드 방문 처리 됐다면 노드 최상단부분 제거 
#          위의 과정을 반복  
#          특정 경로를 갈때, 모든 경로를 탐색 할떄 사용

# DFS 예제(재귀적)
def dfs(graph,v,visted):
    # 현재 노드 방문 처리 
    visted[v] = True
    print(v, end=' ')
    # 현재 노드와 연결된 다른 노드 재귀적으로 방문: 6노드에 연결노드 없으니 다시 7노드의 2번째 연결된 8노드 진행
    for i in graph[v]:
        if not visted[i]:
            dfs(graph,i,visted) 
# 각 노드에 연결된 정보 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2,3,8], #1노드에 연결된 노드
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]
#각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False]*9
dfs(graph,1,visited) 